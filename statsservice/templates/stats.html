{% extends "layout.html" %}
{% block content %}
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Threats</h2>
      <p>Averages based on <i>count</i>.</p>
		  <canvas id="canvas-threats"></canvas>
    </div>
  </div>
  <br />
  <div class="row">
    <div class="col">
      <h2>Vulnerabilities</h2>
      <p>Averages based on <i>count</i>.</p>
		  <canvas id="canvas-vulnerabilities"></canvas>
    </div>
	</div>
  <div class="row">
    <div class="col">
      <p class=""><br />Data based on aggregated statistics from several <a href="https://www.monarc.lu">MONARC instances</a>. More information about the <a href="https://github.com/monarc-project/stats-service/blob/master/docs/architecture.rst">sharing of stats</a>.</p>
    </div>
  </div>
</div><!-- /.container -->
<script>
(function() {
  // define some colors for the lines of the chart
  window.chartColors = [
    'rgba(230, 25, 75, 0.8)',
    'rgba(60, 180, 75, 0.8)',
    'rgba(255, 225, 25, 0.8)',
    'rgba(0, 130, 200, 0.8)',
    'rgba(245, 130, 48, 0.8)',
    'rgba(145, 30, 180, 0.8)',
    'rgba(70, 240, 240, 0.8)',
    'rgba(240, 50, 230, 0.8)',
    'rgba(210, 245, 60, 0.8)',
    'rgba(250, 190, 190, 0.8)',
    'rgba(0, 128, 128, 0.8)',
    'rgba(230, 190, 255, 0.8)',
    'rgba(170, 110, 40, 0.8)',
    'rgba(255, 250, 200, 0.8)',
    'rgba(128, 0, 0, 0.8)',
    'rgba(170, 255, 195, 0.8)',
    'rgba(128, 128, 0, 0.8)',
    'rgba(255, 215, 180, 0.8)',
    'rgba(0, 0, 128, 0.8)',
    'rgba(128, 128, 128, 0.8)',
    'rgba(0, 0, 0, 0.8)'
  ];
  var color = Chart.helpers.color;
  // basic configuration of the charts (threats and vulnerabilities)
  var config = {
    type: 'line',
    data: {
      datasets: []
    },
    options: {
      scales: {
        xAxes: [{
          offset: true,
          type: "time",
          time: {
            unit: 'day',
            round: 'day',
            displayFormats: {
              day: 'MMM D'
            }
          }
        }],
        yAxes: [{
          ticks: {
            beginAtZero: true
          }
        }]
      },
      legend: {
        display: true,
        position: 'right'
      }
    }
  }

  let retrieve_information_from_mosp = function(uuid, language) {
    return new Promise(function(resolve, reject) {
      fetch("https://objects.monarc.lu/api/v2/object/?language="+language+"&uuid="+uuid, {
        method: "GET",
        headers: {
          'Content-Type': 'text/plain',
        },
      })
      .then((resp) => resp.json())
      .then(function(mosp_result) {
        if (mosp_result["metadata"].count > 0) {
          resolve(mosp_result["data"][0].name);
        } else {
          resolve(uuid);
        }
      })
      .catch((error) => {
        console.error('Error:', error);
        reject(Error(error));
      });;
    });
  }

  // fetch stats for threats (averages per threats per date)
  fetch("{{ url_for('stats_bp.threats', postprocessor='threat_average_on_date', days=365) | safe }}", {
    method: "GET",
    headers: {
      'Content-Type': 'application/json',
    },
  })
  .then((resp) => resp.json())
  .then(function(resp_json) {
    // retrieve the labels from MOSP corresponding to the UUID in the result with a promise
    // (we limit the datasets to the number of previously defined colors)
    threat_uuid_labels = {};
    var promises = Object.keys(resp_json).slice(0, window.chartColors.length).map(function(threat_uuid, index) {
      return retrieve_information_from_mosp(threat_uuid, "EN")
      .then(function(result_mosp) {
        threat_uuid_labels[threat_uuid] = result_mosp
        return threat_uuid;
      })
    })

    // wait that we have all responses from MOSP
    Promise.all(promises).then(function(results) {
      // initializes a configuration variable for the chart
      var config_threats = JSON.parse(JSON.stringify(config));
      // construct the datasets
      datasets = [];
      Object.keys(threat_uuid_labels).map(function(threat_uuid, index) {
        data = [];
        dataset = {
          "label": threat_uuid_labels[threat_uuid],
          "backgroundColor": color(window.chartColors[index]).alpha(0.5).rgbString(),
          "borderColor": window.chartColors[index],
          "fill": false,
        };
        Object.keys(resp_json[threat_uuid]).map(function(date, index2) {
          data.push({
            x: new Date(date),
            y: resp_json[threat_uuid][date]["count"]
          })
        });
        dataset["data"] = data;
        datasets.push(dataset);
      })

      // finally set the datasets in the config variable
      config_threats["data"]["datasets"] = datasets;

      // draw the chart
      var ctx_threats = document.getElementById("canvas-threats").getContext("2d");
      var chart_threats = new Chart(ctx_threats, config_threats);
    })


  }).catch((error) => {
    console.error('Error:', error);
  });;



  // fetch stats for vulnerabilities (averages per vulnerabilities per date)
  fetch("{{ url_for('stats_bp.vulnerabilities', postprocessor='vulnerability_average_on_date', days=365) | safe }}", {
    method: "GET",
    headers: {
      'Content-Type': 'application/json',
    },
  })
  .then((resp) => resp.json())
  .then(function(resp_json) {
    // retrieve the labels from MOSP corresponding to the UUID in the result with a promise
    // (we limit the datasets to the number of previously defined colors)
    vulnerability_uuid_labels = {};
    var promises = Object.keys(resp_json).slice(0, window.chartColors.length).map(function(vulnerability_uuid, index) {
      return retrieve_information_from_mosp(vulnerability_uuid, "")
      .then(function(result_mosp) {
        vulnerability_uuid_labels[vulnerability_uuid] = result_mosp
        return vulnerability_uuid;
      })
    })

    Promise.all(promises).then(function(results) {
      // initializes a configuration variable for the chart
      var config_vulnerabilities = JSON.parse(JSON.stringify(config));
      // construct the datasets
      datasets = [];
      Object.keys(vulnerability_uuid_labels).map(function(vulnerability_uuid, index) {
        data = [];
        dataset = {
          "label": vulnerability_uuid_labels[vulnerability_uuid],
          "backgroundColor": color(window.chartColors[index]).alpha(0.5).rgbString(),
          "borderColor": window.chartColors[index],
          "fill": false,
        };
        Object.keys(resp_json[vulnerability_uuid]).map(function(date, index2) {
          data.push({
            x: new Date(date),
            y: resp_json[vulnerability_uuid][date]["count"]
          })
        });
        dataset["data"] = data;
        datasets.push(dataset);
      })

      // finally set the datasets in the config variable
      config_vulnerabilities["data"]["datasets"] = datasets;

      // draw the chart
      var ctx_vulnerabilities = document.getElementById("canvas-vulnerabilities").getContext("2d");
      var chart_vulnerabilities = new Chart(ctx_vulnerabilities, config_vulnerabilities);
    })


  }).catch((error) => {
    console.error('Error:', error);
  });;






  // Test: fetch stats for threats
  // fetch("{{ url_for('stats_bp.threats',) }}", {
  //   method: "GET",
  //   headers: {
  //     'Content-Type': 'application/json',
  //   },
  // })
  // .then((resp) => resp.json())
  // .then(function(data) {
  //   Object.keys(data).map(function(threat_uuid, value) {
  //     console.log(data[threat_uuid]);
  //
  //   })
  // })
  // .catch((error) => {
  //   console.error('Error:', error);
  // });;


  // Test: fetch stats for risks
  // fetch("{{ url_for('stats_bp.risks',) }}", {
  //   method: "GET",
  //   headers: {
  //     'Content-Type': 'application/json',
  //   },
  // }).then(res => {
  //   console.log("Request complete! response:", res);
  // }).catch((error) => {
  //   console.error('Error:', error);
  // });;
})();
</script>
{% endblock %}
