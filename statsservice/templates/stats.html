<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="MONARC Stats Service - Global dashboard" />
    <meta name="author" content="" />
    <title>Global dashboard</title>
    <script src="{{ url_for('static', filename='npm_components/chart.js/dist/Chart.bundle.min.js') }}"></script>
</head>
<body>
  <div style="width:75%; margin:0 auto;">
    <h1>Averages per threats (based on <i>count</i>)</h1>
		<canvas id="canvas-threats"></canvas>
	</div>
  <div style="width:75%; margin:0 auto;">
    <h1>Averages per vulnerabilities (based on <i>count</i>)</h1>
		<canvas id="canvas-vulnerabilities"></canvas>
	</div>
<script>
(function() {
  // define some colors for the lines of the chart
  window.chartColors = [
    'rgba(230, 25, 75, 0.8)',
    'rgba(60, 180, 75, 0.8)',
    'rgba(255, 225, 25, 0.8)',
    'rgba(0, 130, 200, 0.8)',
    'rgba(245, 130, 48, 0.8)',
    'rgba(145, 30, 180, 0.8)',
    'rgba(70, 240, 240, 0.8)',
    'rgba(240, 50, 230, 0.8)',
    'rgba(210, 245, 60, 0.8)',
    'rgba(250, 190, 190, 0.8)',
    'rgba(0, 128, 128, 0.8)',
    'rgba(230, 190, 255, 0.8)',
    'rgba(170, 110, 40, 0.8)',
    'rgba(255, 250, 200, 0.8)',
    'rgba(128, 0, 0, 0.8)',
    'rgba(170, 255, 195, 0.8)',
    'rgba(128, 128, 0, 0.8)',
    'rgba(255, 215, 180, 0.8)',
    'rgba(0, 0, 128, 0.8)',
    'rgba(128, 128, 128, 0.8)',
    'rgba(0, 0, 0, 0.8)'
  ];
  var color = Chart.helpers.color;
  // basic configuration of the charts (threats and vulnerabilities)
  var config = {
    type: 'line',
    data: {
      datasets: []
    },
    options: {
      scales: {
        xAxes: [{
          offset: true,
          type: "time",
          time: {
            unit: 'day',
            round: 'day',
            displayFormats: {
              day: 'MMM D'
            }
          }
        }],
        yAxes: [{
          ticks: {
            beginAtZero: true
          }
        }]
      }
    }
  }

  let retrieve_information_from_mosp = function(uuid) {
    return new Promise(function(resolve, reject) {
      fetch("https://objects.monarc.lu/api/v2/object/?language=EN&uuid="+uuid, {
        method: "GET",
        headers: {
          'Content-Type': 'text/plain',
        },
      })
      .then((resp) => resp.json())
      .then(function(mosp_result) {
        // console.log(mosp_result["data"][0].name);
        resolve(mosp_result);
      })
      .catch((error) => {
        console.error('Error:', error);
        reject(Error(error));
      });;
    });
  }

  // fetch stats for threats (averages per threats per date)
  fetch("{{ url_for('stats_bp.threats', postprocessor='threat_average_on_date', days=365) | safe }}", {
    method: "GET",
    headers: {
      'Content-Type': 'application/json',
    },
  })
  .then((resp) => resp.json())
  .then(function(resp_json) {
    // retrieve the labels from MOSP corresponding to the UUID in the result with a promise
    // (we limit the datasets to the number of previously defined colors)
    threat_uuid_labels = {};
    var promises = Object.keys(resp_json).slice(0, window.chartColors.length).map(function(threat_uuid, index) {
      return retrieve_information_from_mosp(threat_uuid)
      .then(function(result_mosp) {
        threat_uuid_labels[threat_uuid] = result_mosp["data"][0].name
        return threat_uuid;
      })
    })

    // wait that we have all responses from MOSP
    Promise.all(promises).then(function(results) {
      // initializes a configuration variable for the chart
      var config_threats = JSON.parse(JSON.stringify(config));
      // construct the datasets
      datasets = [];
      Object.keys(threat_uuid_labels).map(function(threat_uuid, index) {
        data = [];
        dataset = {
          "label": threat_uuid_labels[threat_uuid],
          "backgroundColor": color(window.chartColors[index]).alpha(0.5).rgbString(),
          "borderColor": window.chartColors[index],
          "fill": false,
        };
        Object.keys(resp_json[threat_uuid]).map(function(date, index2) {
          data.push({
            x: new Date(date),
            y: resp_json[threat_uuid][date]["count"]
          })
        });
        dataset["data"] = data;
        datasets.push(dataset);
      })

      // finally set the datasets in the config variable
      config_threats["data"]["datasets"] = datasets;

      // draw the chart
      var ctx_threats = document.getElementById("canvas-threats").getContext("2d");
      var chart_threats = new Chart(ctx_threats, config_threats);
    })


  }).catch((error) => {
    console.error('Error:', error);
  });;



  // fetch stats for vulnerabilities (averages per vulnerabilities per date)
  fetch("{{ url_for('stats_bp.vulnerabilities', postprocessor='vulnerability_average_on_date', days=365) | safe }}", {
    method: "GET",
    headers: {
      'Content-Type': 'application/json',
    },
  })
  .then((resp) => resp.json())
  .then(function(resp_json) {
    // retrieve the labels from MOSP corresponding to the UUID in the result with a promise
    // (we limit the datasets to the number of previously defined colors)
    vulnerability_uuid_labels = {};
    var promises = Object.keys(resp_json).slice(0, window.chartColors.length).map(function(vulnerability_uuid, index) {
      return retrieve_information_from_mosp(vulnerability_uuid)
      .then(function(result_mosp) {
        vulnerability_uuid_labels[vulnerability_uuid] = result_mosp["data"][0].name
        return vulnerability_uuid;
      })
    })

    Promise.all(promises).then(function(results) {
      // initializes a configuration variable for the chart
      var config_vulnerabilities = JSON.parse(JSON.stringify(config));
      // construct the datasets
      datasets = [];
      Object.keys(vulnerability_uuid_labels).map(function(vulnerability_uuid, index) {
        data = [];
        dataset = {
          "label": vulnerability_uuid_labels[vulnerability_uuid],
          "backgroundColor": color(window.chartColors[index]).alpha(0.5).rgbString(),
          "borderColor": window.chartColors[index],
          "fill": false,
        };
        Object.keys(resp_json[vulnerability_uuid]).map(function(date, index2) {
          data.push({
            x: new Date(date),
            y: resp_json[vulnerability_uuid][date]["count"]
          })
        });
        dataset["data"] = data;
        datasets.push(dataset);
      })

      // finally set the datasets in the config variable
      config_vulnerabilities["data"]["datasets"] = datasets;

      // draw the chart
      var ctx_vulnerabilities = document.getElementById("canvas-vulnerabilities").getContext("2d");
      var chart_vulnerabilities = new Chart(ctx_vulnerabilities, config_vulnerabilities);
    })


  }).catch((error) => {
    console.error('Error:', error);
  });;






  // Test: fetch stats for threats
  // fetch("{{ url_for('stats_bp.threats',) }}", {
  //   method: "GET",
  //   headers: {
  //     'Content-Type': 'application/json',
  //   },
  // })
  // .then((resp) => resp.json())
  // .then(function(data) {
  //   Object.keys(data).map(function(threat_uuid, value) {
  //     console.log(data[threat_uuid]);
  //
  //     // fetch inforation about relevant threats from MOSP
  //     retrieve_information_from_mosp(threat_uuid);
  //
  //
  //   })
  // })
  // .catch((error) => {
  //   console.error('Error:', error);
  // });;


  // Test: fetch stats for risks
  // fetch("{{ url_for('stats_bp.risks',) }}", {
  //   method: "GET",
  //   headers: {
  //     'Content-Type': 'application/json',
  //   },
  // }).then(res => {
  //   console.log("Request complete! response:", res);
  // }).catch((error) => {
  //   console.error('Error:', error);
  // });;
})();
</script>
</body>
</html>
